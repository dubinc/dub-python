"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dub.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from dub.utils import FieldMetadata, QueryParamMetadata
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class ListPayoutsQueryParamStatus(str, Enum):
    r"""Filter the list of payouts by their corresponding status."""

    PENDING = "pending"
    PROCESSING = "processing"
    PROCESSED = "processed"
    SENT = "sent"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELED = "canceled"


class ListPayoutsQueryParamSortBy(str, Enum):
    r"""The field to sort the list of payouts by."""

    AMOUNT = "amount"
    INITIATED_AT = "initiatedAt"
    PAID_AT = "paidAt"


class ListPayoutsQueryParamSortOrder(str, Enum):
    r"""The sort order for the list of payouts."""

    ASC = "asc"
    DESC = "desc"


class ListPayoutsRequestTypedDict(TypedDict):
    status: NotRequired[ListPayoutsQueryParamStatus]
    r"""Filter the list of payouts by their corresponding status."""
    partner_id: NotRequired[str]
    r"""Filter the list of payouts by the associated partner. When specified, takes precedence over `tenantId`."""
    tenant_id: NotRequired[str]
    r"""Filter the list of payouts by the associated partner's `tenantId` (their unique ID within your database)."""
    invoice_id: NotRequired[str]
    r"""Filter the list of payouts by invoice ID (the unique ID of the invoice you receive for each batch payout you process on Dub). Pending payouts will not have an invoice ID."""
    sort_by: NotRequired[ListPayoutsQueryParamSortBy]
    r"""The field to sort the list of payouts by."""
    sort_order: NotRequired[ListPayoutsQueryParamSortOrder]
    r"""The sort order for the list of payouts."""
    page: NotRequired[float]
    r"""The page number for pagination."""
    page_size: NotRequired[float]
    r"""The number of items per page."""


class ListPayoutsRequest(BaseModel):
    status: Annotated[
        Optional[ListPayoutsQueryParamStatus],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Filter the list of payouts by their corresponding status."""

    partner_id: Annotated[
        Optional[str],
        pydantic.Field(alias="partnerId"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Filter the list of payouts by the associated partner. When specified, takes precedence over `tenantId`."""

    tenant_id: Annotated[
        Optional[str],
        pydantic.Field(alias="tenantId"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Filter the list of payouts by the associated partner's `tenantId` (their unique ID within your database)."""

    invoice_id: Annotated[
        Optional[str],
        pydantic.Field(alias="invoiceId"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Filter the list of payouts by invoice ID (the unique ID of the invoice you receive for each batch payout you process on Dub). Pending payouts will not have an invoice ID."""

    sort_by: Annotated[
        Optional[ListPayoutsQueryParamSortBy],
        pydantic.Field(alias="sortBy"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = ListPayoutsQueryParamSortBy.AMOUNT
    r"""The field to sort the list of payouts by."""

    sort_order: Annotated[
        Optional[ListPayoutsQueryParamSortOrder],
        pydantic.Field(alias="sortOrder"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = ListPayoutsQueryParamSortOrder.DESC
    r"""The sort order for the list of payouts."""

    page: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 1
    r"""The page number for pagination."""

    page_size: Annotated[
        Optional[float],
        pydantic.Field(alias="pageSize"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 100
    r"""The number of items per page."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "status",
                "partnerId",
                "tenantId",
                "invoiceId",
                "sortBy",
                "sortOrder",
                "page",
                "pageSize",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListPayoutsStatus(str, Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    PROCESSED = "processed"
    SENT = "sent"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELED = "canceled"


class ListPayoutsMode(str, Enum):
    INTERNAL = "internal"
    EXTERNAL = "external"


class ListPayoutsPartnerTypedDict(TypedDict):
    id: str
    r"""The partner's unique ID on Dub."""
    name: str
    r"""The partner's full legal name."""
    email: Nullable[str]
    r"""The partner's email address. Should be a unique value across Dub."""
    image: Nullable[str]
    r"""The partner's avatar image."""
    payouts_enabled_at: Nullable[str]
    r"""The date when the partner enabled payouts."""
    country: Nullable[str]
    r"""The partner's country (required for tax purposes)."""
    tenant_id: Nullable[str]
    r"""The partner's unique ID within your database. Can be useful for associating the partner with a user in your database and retrieving/update their data in the future."""
    group_id: NotRequired[Nullable[str]]
    r"""The partner's group ID on Dub."""


class ListPayoutsPartner(BaseModel):
    id: str
    r"""The partner's unique ID on Dub."""

    name: str
    r"""The partner's full legal name."""

    email: Nullable[str]
    r"""The partner's email address. Should be a unique value across Dub."""

    image: Nullable[str]
    r"""The partner's avatar image."""

    payouts_enabled_at: Annotated[
        Nullable[str], pydantic.Field(alias="payoutsEnabledAt")
    ]
    r"""The date when the partner enabled payouts."""

    country: Nullable[str]
    r"""The partner's country (required for tax purposes)."""

    tenant_id: Annotated[Nullable[str], pydantic.Field(alias="tenantId")]
    r"""The partner's unique ID within your database. Can be useful for associating the partner with a user in your database and retrieving/update their data in the future."""

    group_id: Annotated[OptionalNullable[str], pydantic.Field(alias="groupId")] = UNSET
    r"""The partner's group ID on Dub."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["groupId"])
        nullable_fields = set(
            ["email", "image", "payoutsEnabledAt", "country", "groupId", "tenantId"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class UserTypedDict(TypedDict):
    id: str
    name: Nullable[str]
    email: Nullable[str]
    image: Nullable[str]


class User(BaseModel):
    id: str

    name: Nullable[str]

    email: Nullable[str]

    image: Nullable[str]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class ListPayoutsResponseBodyTypedDict(TypedDict):
    id: str
    invoice_id: Nullable[str]
    amount: float
    currency: str
    status: ListPayoutsStatus
    period_start: Nullable[str]
    period_end: Nullable[str]
    created_at: str
    initiated_at: Nullable[str]
    paid_at: Nullable[str]
    mode: Nullable[ListPayoutsMode]
    partner: ListPayoutsPartnerTypedDict
    description: NotRequired[Nullable[str]]
    failure_reason: NotRequired[Nullable[str]]
    user: NotRequired[Nullable[UserTypedDict]]


class ListPayoutsResponseBody(BaseModel):
    id: str

    invoice_id: Annotated[Nullable[str], pydantic.Field(alias="invoiceId")]

    amount: float

    currency: str

    status: ListPayoutsStatus

    period_start: Annotated[Nullable[str], pydantic.Field(alias="periodStart")]

    period_end: Annotated[Nullable[str], pydantic.Field(alias="periodEnd")]

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    initiated_at: Annotated[Nullable[str], pydantic.Field(alias="initiatedAt")]

    paid_at: Annotated[Nullable[str], pydantic.Field(alias="paidAt")]

    mode: Nullable[ListPayoutsMode]

    partner: ListPayoutsPartner

    description: OptionalNullable[str] = UNSET

    failure_reason: Annotated[
        OptionalNullable[str], pydantic.Field(alias="failureReason")
    ] = UNSET

    user: OptionalNullable[User] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["description", "failureReason", "user"])
        nullable_fields = set(
            [
                "invoiceId",
                "description",
                "periodStart",
                "periodEnd",
                "initiatedAt",
                "paidAt",
                "failureReason",
                "mode",
                "user",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


try:
    ListPayoutsPartner.model_rebuild()
except NameError:
    pass
try:
    ListPayoutsResponseBody.model_rebuild()
except NameError:
    pass
